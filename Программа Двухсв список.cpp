/*
<<ЗАДАЧА 2>>
Реализовать двухсвязный список с сортировкой.
*/

#include <stdio.h>
#include <stdlib.h>
#include <iostream>                    // поток ввода - вывода
#include <clocale>                     // подключение для рускоязычной консоли

using namespace std;

struct node
{
	int data;                          // значение ячейки (поля)
	node* prev;                        // указатель на предыдущий элемент
	node* next;						   // указатель на следующий элемент
};

struct list
{
	int size;                           // количество элементов в списке
	node* up;                           // указатель на первый элемент
	node* down;                         // указатель на последний элемент
};

void push_back(list *L);                // прототип функции "добавление элемента в конец"
int pop_back(list *L);                  // прототип функции "удаление элемента из конца"
void push_front(list *L);               // прототип функции "добавление элемента в начало"
int pop_front(list *L);                 // прототип функции "удаление элемента из начала"
void step_by_step(list *L);             // прототип функции, обобщающий все действия выше
void insert(list *L);					// прототип функции "вставка с любое место списка"
void output(list *L);					// прототип функции "вывод двухсвязного списка"
void sort(list *L);

int main()
{
	setlocale(LC_ALL, "Rus");           // функция для ввода русского языка
	list List;                          // макет cписка 
	List.size = 0;                      // количество элементов пока что нулевое
	List.up = NULL;                     // обнуление вершины
	List.down = NULL;					// обнуление низа
	step_by_step(&List);
	system("pause");
	return 0;
}

void step_by_step(list *L)
{
	int n;
	cout << "Введите количество элементов в список: ";
	cin >> n;
	cout << "Добавление элемента в список: " << endl;
	for (int i = 0; i < n; i++)
	{
		push_back(L);
		push_front(L);
	}
}

void push_front(list *L)				// функция для добавления элемента в начало
{
	int value;							// значение вводимой переменной
	cin >> value;						// ввод переменной
	node* value_pointer = new node;		// выделение памяти под новую ячейку в списке
	value_pointer->data = value;		// получение введенного числа
	value_pointer->prev = L->up;		// адрес предыдущей ячейки = адрес вершины(старой)
	L->up = value_pointer;				// получение адреса для первого элемента, который станет вершиной(новой)
	L->size++;							// увеличение элементов в списке путем добавления нового
}

int pop_front(list *L)					// функция для удаления элемента из начала
{
	int value_temp = 0;					// временная переменная для хранения вершины(старой)
	node *value_pointer;				// указатель на структуру, которую удалим
	value_pointer = L->up;				// адрес вершины(старой) приравнивается к указателю 
	value_temp = L->up->data;			// в врем. значении хранится значение вершины по адресу вершины(старой)
	L->up = value_pointer->prev;		// предыдущ. элемент станет вершиной(новой)
	delete value_pointer;				// освобождаем память в которой находится вершина(старая)
	L->size--;							// уменьшение элементов в списке путем удаление старого
	return value_temp;					// возвращаем значение вершины(старой)
}

void push_back(list *L)
{
	int value;							// значение вводимой переменной
	cin >> value;						// ввод переменной
	node* value_pointer = new node;		// выделение памяти под новую ячейку в списке
	value_pointer->data = value;		// получение введенного числа
	value_pointer->next = L->down;		// адрес следующ. ячейки = адрес низа(старого)
	L->down = value_pointer;			// получение адреса для последнего элемента, который станет низом(новым)
	L->size++;							// увеличение элементов в списке путем добавление нового
}

int pop_back(list *L)
{
	int value_temp = 0;					// временная переменная для хранения низа(старого)
	node *value_pointer;				// указатель на структуру, которую удалим
	value_pointer = L->down;			// адрес низа(старого) приравнивается к указателю 
	value_temp = L->down->data;			// в врем. значении хранится значение низа по адресу низа(старого)
	L->down = value_pointer->next;		// следующий элемент станет низом(новым)
	delete value_pointer;				// освобождаем память в которой находится низ(старый)
	L->size--;							// уменьшение элементов в списке путем удаление старого
	return value_temp;					// возвращаем значение низа(старого)
}

void insert(list *L)
{
	//
}

void output(list *L)
{
	//
} 

void sort(list *L)
{
	//
}